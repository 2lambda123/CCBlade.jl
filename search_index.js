var documenterSearchIndex = {"docs":
[{"location":"#CCBlade-Documentation-1","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"","category":"section"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"Summary: A blade element momentum method for propellers and turbines. ","category":"page"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"Author: Andrew Ning","category":"page"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"Features:","category":"page"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"Prandtl hub/tip losses\nGlauert/Buhl empirical region for high thrust turbines\nConvenience functions for inflow with shear, precone, yaw, tilt, and azimuth\nAllows for flow reversals (negative inflow/rotation velocities)\nAllows for a hover condition (only rotation, no inflow) and rotor locked (no rotation, only inflow)\nMethodology is provably convergent (see http://dx.doi.org/10.1002/we.1636 although multiple improvements have been made since then)\nCompatible with AD tools like ForwardDiff","category":"page"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"Installation:","category":"page"},{"location":"#","page":"CCBlade Documentation","title":"CCBlade Documentation","text":"pkg> add https://github.com/byuflowlab/CCBlade.jl","category":"page"},{"location":"tutorial/#Guide-1","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"This section contains two examples, one for a wind turbine and one for a propeller.  Each function in the module is introduced along the way.  Because the workflow for the propeller is essentially the same as that for the wind turbine (except the operating point), the propeller example does not repeat the same level of detail or comments.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"To start, we import CCBlade as well as a plotting module.  I prefer to use import rather than using as it makes the namespace clear when multiple modules exist (except with plotting where it is obvious), but for the purposes of keeping this example concise I will use using.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"All angles should be in radians.  The only exception is the airfoil input file, which has angle of attack in degrees for readability.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"tutorial/#Wind-Turbine-1","page":"Guide","title":"Wind Turbine","text":"","category":"section"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"First, we need to define the geometric parameterization.  This example approximately corresponds to the NREL 5MW reference wind turbine.  There are two structs to define the geometry, the first is for the whole rotor, and the second defines properties that vary along the blade radius.  The first is the rotor:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Rotor","category":"page"},{"location":"tutorial/#CCBlade.Rotor","page":"Guide","title":"CCBlade.Rotor","text":"Rotor(Rhub, Tip, B, turbine, pitch, precone)\n\nScalar parameters defining the rotor.  \n\nArguments\n\nRhub::Float64: hub radius (along blade length)\nRtip::Float64: tip radius (along blade length)\nB::Int64: number of blades\nturbine::Bool: true if turbine, false if propeller\npitch::Float64: pitch angle (rad).  defined same direction as twist.\nprecone::Float64: precone angle\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Rhub/Rtip define the hub and tip radius and are used for hub/tip corrections, for integration of loads, and for nondimensionalization.    The parameter turbine just changes the input/output conventions.  If turbine=true then the following positive directions for inputs, induced velocities, and loads are used as shown in the figure below.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The definition for the precone is shown below.  Note that there is a convenience constructor where precone is omitted (defaults to zero) because while precone is often used for wind turbines it is rarely used for propellers.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Let's define these rotor properties:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"\nRhub = 1.5\nRtip = 63.0\nB = 3\nturbine = true\npitch = 0.0\nprecone = 2.5*pi/180\n\nrotor = Rotor(Rhub, Rtip, B, turbine, pitch, precone)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Next we need to define the section properties that vary along the blade radius.  The section object defines a single radial station:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Section","category":"page"},{"location":"tutorial/#CCBlade.Section","page":"Guide","title":"CCBlade.Section","text":"Section(r, chord, theta, af)\n\nDefine sectional properties for one station along rotor\n\nArguments\n\nr::Float64: radial location along turbine (Rhub < r < Rtip)\nchord::Float64: corresponding local chord length\ntheta::Float64: corresponding twist angle (radians)\naf::function: a function of the form: cl, cd = af(alpha, Re, Mach)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Note that r is the distance along the blade, rather than in the rotor plane.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We'll define all these properties now, except for the airfoils as those will take more explanation","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"\nr = [2.8667, 5.6000, 8.3333, 11.7500, 15.8500, 19.9500, 24.0500,\n    28.1500, 32.2500, 36.3500, 40.4500, 44.5500, 48.6500, 52.7500,\n    56.1667, 58.9000, 61.6333]\nchord = [3.542, 3.854, 4.167, 4.557, 4.652, 4.458, 4.249, 4.007, 3.748,\n    3.502, 3.256, 3.010, 2.764, 2.518, 2.313, 2.086, 1.419]\ntheta = pi/180*[13.308, 13.308, 13.308, 13.308, 11.480, 10.162, 9.011, 7.795,\n    6.544, 5.361, 4.188, 3.125, 2.319, 1.526, 0.863, 0.370, 0.106]\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"warning: Warning\nYou must have Rhub < r < Rtip for all r.  These are strict inequalities (not equal to).","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The airfoil input is any function of the form: cl, cd = airfoil(alpha, Re, Mach) where cl and cd are the lift and drag coefficient respectively, alpha is the angle of attack in radians, Re is the Reynolds number, and Mach is the Mach number.  Some of the inputs can be ignored if desired (e.g., Mach number).  While users can supply any function, two convenience methods exist for creating these functions.  One takes data from files, the other uses input arrays.  Both convert the data into a smooth spline (currently an Akima spline, or recursive Akima splines in higher dimensions).","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The required file format contains one header line that is ignored in parsing.  Its purpose is to allow you to record any information you want about the data in that file (e.g., where it came from, type of corrections applied, Reynolds number, etc.).  The rest of the file contains data in columns split by  whitespace (not commas) in the following order: alpha, cl, cd.  You can add additional columns of data (e.g., cm), but they will be ignored in this module.  One file corresponds to one Reynolds number and one Mach number.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"For example, a simple file (a cylinder section) would look like:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Cylinder section with a Cd of 0.50.  Re = 1 million.\n-180.0   0.000   0.5000   0.000\n0.00     0.000   0.5000   0.000\n180.0    0.000   0.5000   0.000","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"There are three options for constructing from files.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"af_from_files(filenames; Re=[], Mach=[])","category":"page"},{"location":"tutorial/#CCBlade.af_from_files-Tuple{Any}","page":"Guide","title":"CCBlade.af_from_files","text":"af_from_files(filenames; Re=[], Mach=[])\n\nRead airfoil file(s) and return a function of the form cl, cd = func(alpha, Re, M)\n\nIf filenames is just one file, then Re and Mach are ignored (just aoa variation). af_file_files(\"somefile.dat\")\n\nIf filenames is a vector then there is variation with either Re or Mach (both not both). af_file_files([\"f1.dat\", \"f2.dat\", \"f3.dat\"], Mach=[0.5, 0.6, 0.7])\n\nFilenames can be a matrix for variation with both. af_file_files(filematrix, Re=[3e6, 5e6], Mach=[0.5, 0.6, 0.7]) where filematrix[i, j] correspnds to Re[i], Mach[j]\n\nUses the af_from_data function.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The first is a single file.  In that case the data varies only with with angle of attack.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"afexample = af_from_files(\"airfoil.dat\")","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The second case is a list of files that correspond to different Reynolds numbers, or different Mach numbers.  In this case the variation is with angle of attack and either Re or Mach.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"afexample = af_from_files([\"airfoil_Re1.dat\", \"airfoil_Re2.dat\"], Re=[1e5, 2e5])","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"or","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"afexample = af_from_files([\"airfoil_M6.dat\", \"airfoil_M7.dat\"], Mach=[0.6, 0.7])","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The last case is a matrix of files to allow for simultaneous variation in angle of attack, Reynolds number, and Mach number.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"afexample = af_from_files([[\"af_Re1_M6.dat\" \"af_Re1_M68.dat\" \"af_Re1_M7.dat\"]; \n    [\"af_Re2_M6.dat\" \"af_Re2_M68.dat\" \"af_Re2_M7.dat\"]], \n    Re=[1e5, 2e5], Mach=[0.6, 0.68, 0.7])","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Alternatively, if you have the alpha, cl, cd data already in vectors you can initialize directly from the vectors:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"af_from_data(alpha, Re, Mach, cl, cd)","category":"page"},{"location":"tutorial/#CCBlade.af_from_data-NTuple{5,Any}","page":"Guide","title":"CCBlade.af_from_data","text":"Create an airfoil function directly from alpha, cl, and cd arrays. The function of the form cl, cd = func(alpha, Re, M) alpha should be in radians.  Uses an akima spline.  af_from_files calls this function.\n\ncl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\n\nIf Mach=[] cl[i, j] corresponds to alpha[i], Re[j] size(cl) = (length(alpha), length(Re)) But you can use a singleton dimension for the constant Mach if desired. size(cl) = (length(alpha), length(Re), 1) The above also applies for Re=[] where variation is with alpha and Mach.\n\nThere is also a convenience method for vector data with just aoa variation af_from_data(alpha, cl, cd) which just corresponds to af_from_data(alpha, Re=[], Mach=[], cl, cd)\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"There is also a convenience method for cases with only variation in angle of attack.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"af_from_data(alpha, cl, cd)","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"In this example, we will initialize from files since the data arrays would be rather long.  The only complication is that there are 8 different airfoils used at the 17 different radial stations so we need to assign them to the correct stations corresponding to the vector r defined previously.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"# Define airfoils.  In this case we have 8 different airfoils that we load into an array.\n# These airfoils are defined in files.\naftypes = Array{Any}(undef, 8)\naftypes[1] = af_from_files(\"airfoils/Cylinder1.dat\")\naftypes[2] = af_from_files(\"airfoils/Cylinder2.dat\")\naftypes[3] = af_from_files(\"airfoils/DU40_A17.dat\")\naftypes[4] = af_from_files(\"airfoils/DU35_A17.dat\")\naftypes[5] = af_from_files(\"airfoils/DU30_A17.dat\")\naftypes[6] = af_from_files(\"airfoils/DU25_A17.dat\")\naftypes[7] = af_from_files(\"airfoils/DU21_A17.dat\")\naftypes[8] = af_from_files(\"airfoils/NACA64_A17.dat\")\n\n# indices correspond to which airfoil is used at which station\naf_idx = [1, 1, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8]\n\n# create airfoil array \nairfoils = aftypes[af_idx]\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We can now define the sections using this airfoil data.  Since Section is defined for one section, and we'd like to define them all simultaneously, we use broadcasting (see the dot after Section).","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"sections = Section.(r, chord, theta, airfoils)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Next, we need to specify the operating conditions.  At a basic level the inflow conditions need to be defined as a struct defined by OperatingPoint.  The parameters mu and asound are optional if Reynolds number and Mach number respectively are not used in the airfoil functions.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"OperatingPoint","category":"page"},{"location":"tutorial/#CCBlade.OperatingPoint","page":"Guide","title":"CCBlade.OperatingPoint","text":"OperatingPoint(Vx, Vy, rho, mu=1.0, asound=1.0)\n\nOperation point for a rotor.   The x direction is the axial direction, and y direction is the tangential direction in the rotor plane.   See Documentation for more detail on coordinate systems. Vx and Vy vary radially at same locations as r in the rotor definition.\n\nArguments\n\nVx::Float64: velocity in x-direction along blade\nVy::Float64: velocity in y-direction along blade\nrho::Float64: fluid density\nmu::Float64: fluid dynamic viscosity (unused if Re not included in airfoil data)\nasound::Float64: fluid speed of sound (unused if Mach not included in airfoil data)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The coordinate system for Vx and Vy is shown at the top of Wind Turbine.  In general, different inflow conditions will exist at every location along the blade. The above type allows one to specify an arbitrary input definition, however, convenience methods exist for a few typical inflow conditions.  For a typical wind turbine operating point you can use the windturbine_op function, which is based on the angles and equations shown below.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"To account for the velocity change across the hub face we compute the height of each blade location relative to the hub using coordinate transformations (where Phi is the precone angle):","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"  z_h = r cosPhi cospsi cosTheta + r sinPhisinTheta","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"then apply the shear exponent (alpha):","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"  V_shear = V_hub left(1 + fracz_hH_hub right)^alpha","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"where H_hub is the hub height.  Finally, we can compute the x- and y-components of velocity with additional coordinate transformations:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"beginaligned\nV_x = V_shear ((cos gamma sin Theta cos psi + sin gamma sin psi)sin Phi + cos gamma cos Theta cos Phi)\nV_y = V_shear (cos gamma sin Thetasin psi - sin gamma cos psi) + Omega r cosPhi\nendaligned","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"windturbine_op","category":"page"},{"location":"tutorial/#CCBlade.windturbine_op","page":"Guide","title":"CCBlade.windturbine_op","text":"windturbine_op(Vhub, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho, mu=1.0, asound=1.0)\n\nCompute relative wind velocity components along blade accounting for inflow conditions and orientation of turbine.  See Documentation for angle definitions.\n\nArguments\n\nVhub::Float64: freestream speed at hub (m/s)\nOmega::Float64: rotation speed (rad/s)\nr::Float64: radial location where inflow is computed (m)\nprecone::Float64: precone angle (rad)\nyaw::Float64: yaw angle (rad)\ntilt::Float64: tilt angle (rad)\nazimuth::Float64: azimuth angle to evaluate at (rad)\nhubHt::Float64: hub height (m) - used for shear\nshearExp::Float64: power law shear exponent\nrho::Float64: air density (kg/m^3)\nmu::Float64: air viscosity (Pa * s)\nasound::Float64: air speed of sound (m/s)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We will use this function for this example, at a tip-speed ratio of 7.55.  We again use broadcasting because the velocities will vary at each radial station r.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"\n# operating point for the turbine\nyaw = 0.0*pi/180\ntilt = 5.0*pi/180\nhubHt = 90.0\nshearExp = 0.2\n\nVinf = 10.0\ntsr = 7.55\nrotorR = Rtip*cos(precone)\nOmega = Vinf*tsr/rotorR\nazimuth = 0.0*pi/180\nrho = 1.225\n\nop = windturbine_op.(Vinf, Omega, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We have now defined the requisite inputs and can start using the BEM methodology.  The solve function is the core of the BEM.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"solve","category":"page"},{"location":"tutorial/#CCBlade.solve","page":"Guide","title":"CCBlade.solve","text":"solve(rotor, section, op)\n\nSolve the BEM equations for given rotor geometry and operating point.\n\nArguments\n\nrotor::Rotor: rotor properties\nsection::Section: section properties\nop::OperatingPoint: operating point\n\nReturns\n\noutputs::Outputs: BEM output data including loads, induction factors, etc.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The output result is a struct defined below. The positive directions for the normal and tangential forces, and the induced velocities are shown at the top of Wind Turbine.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Outputs","category":"page"},{"location":"tutorial/#CCBlade.Outputs","page":"Guide","title":"CCBlade.Outputs","text":"Outputs(Np, Tp, a, ap, u, v, phi, alpha, W, cl, cd, cn, ct, F, G)\n\nOutputs from the BEM solver along the radius.\n\nArguments\n\nNp::Vector{Float64}: normal force per unit length\nTp::Vector{Float64}: tangential force per unit length\na::Vector{Float64}: axial induction factor\nap::Vector{Float64}: tangential induction factor\nu::Vector{Float64}: axial induced velocity\nv::Vector{Float64}: tangential induced velocity\nphi::Vector{Float64}: inflow angle\nalpha::Vector{Float64}: angle of attack\nW::Vector{Float64}: inflow velocity\ncl::Vector{Float64}: lift coefficient\ncd::Vector{Float64}: drag coefficient\ncn::Vector{Float64}: normal force coefficient\nct::Vector{Float64}: tangential force coefficient\nF::Vector{Float64}: hub/tip loss correction\nG::Vector{Float64}: effective hub/tip loss correction for induced velocities: u = Vx * a * G, v = Vy * ap * G\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Note that we use broadcasting to solve all sections in one call.  However, since rotor is not an Array, we wrap it in Ref so that it can broadcast as a \"scalar\".","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"out = solve.(Ref(rotor), sections, op)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Let's now plot the distributed loads.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"# plot distributed loads\nfigure()\nplot(r/Rtip, out.Np/1e3)\nplot(r/Rtip, out.Tp/1e3)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (kN/m)\")\nlegend([\"flapwise\", \"lead-lag\"])\nsavefig(\"loads-turbine.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We are likely also interested in integrated loads, like thrust and torque, which are provided by the function thrusttorque.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"thrusttorque(rotor, sections, outputs::Vector{Outputs{TF}}) where TF","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"T, Q = thrusttorque(rotor, sections, out)","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"As used in the above example, this would give the thrust and torque assuming the inflow conditions were constant with azimuth (overly optimistic with this case at azimuth=0).  If one wanted to compute thrust and torque using azimuthal averaging you would compute multiple inflow conditions with different azimuth angles and then average the resulting forces.  This can be conveniently done with broadcasting.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"To do this we are broadcast across r and az_angles as a matrix of conditions. We will transpose az_angles into a row vector to make this happen.  If uncomforable with broadcasting, all of these could all be done easily with for loops.  The thrusttorque function is overloaded with a version that accepts a matrix of outputs where outputs[i, j] corresponds to r[i], azimuth[j] then performs an integration using averaging across the azimuthal conditions.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"thrusttorque(rotor, sections, outputs::Matrix{Outputs{TF}}) where TF","category":"page"},{"location":"tutorial/#CCBlade.thrusttorque-Union{Tuple{TF}, Tuple{Any,Any,Array{Outputs{TF},2}}} where TF","page":"Guide","title":"CCBlade.thrusttorque","text":"thrusttorque(rotor, sections, outputs::Array{Outputs{TF}, 2}) where TF\n\nIntegrate the thrust/torque across the blade given an array of output data. Generally used for azimuthal averaging of thrust/torque. outputs[i, j] corresponds to sections[i], azimuth[j].  Integrates across azimuth\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"azangles = pi/180*[0.0, 90.0, 180.0, 270.0]\nops = windturbine_op.(Vinf, Omega, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\nouts = solve.(Ref(rotor), sections, ops)\n\nT, Q = thrusttorque(rotor, sections, outs)","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"One final convenience function is to nondimensionalize the outputs.  The nondimensionalization uses different conventions depending on the application.  For a wind turbine the nondimensionalization is:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"beginaligned\nC_T = fracTq A\nC_Q = fracQq R_disk A\nC_P = fracPq A V_hub\nendaligned","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"where","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"beginaligned\nR_disk = R_tip cos(textprecone)\nA = pi R_disk^2\nq = frac12rho V_hub^2\nendaligned","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"nondim","category":"page"},{"location":"tutorial/#CCBlade.nondim","page":"Guide","title":"CCBlade.nondim","text":"nondim(T, Q, Vhub, Omega, rho, rotor)\n\nNondimensionalize the outputs.\n\nArguments\n\nT::Float64: thrust (N)\nQ::Float64: torque (N-m)\nVhub::Float64: hub speed used in turbine normalization (m/s)\nOmega::Float64: rotation speed used in propeller normalization (rad/s)\nrho::Float64: air density (kg/m^3)\nrotor::Rotor: rotor object\n\nReturns\n\nif windturbine\n\nCP::Float64: power coefficient\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\nif propeller\n\neff::Float64: efficiency\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"CP, CT, CQ = nondim(T, Q, Vinf, Omega, rho, rotor)\n","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"As a final example, let's create a nondimensional power curve for this turbine (power coefficient vs tip-speed-ratio):","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"ntsr = 20  # number of tip-speed ratios\ntsrvec = range(2, 15, length=ntsr)\ncpvec = zeros(ntsr)  # initialize arrays\nctvec = zeros(ntsr)\n\nazangles = pi/180*[0.0, 90.0, 180.0, 270.0]\n\nfor i = 1:ntsr\n    Omega = Vinf*tsrvec[i]/rotorR\n\n    ops = windturbine_op.(Vinf, Omega, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\n    outs = solve.(Ref(rotor), sections, ops)\n    T, Q = thrusttorque(rotor, sections, outs)\n\n    cpvec[i], ctvec[i], _ = nondim(T, Q, Vinf, Omega, rho, rotor)\nend\n\nfigure()\nplot(tsrvec, cpvec)\nplot(tsrvec, ctvec)\nxlabel(\"tip speed ratio\")\nlegend([L\"C_P\", L\"C_T\"])\nsavefig(\"cpct-turbine.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#Propellers-1","page":"Guide","title":"Propellers","text":"","category":"section"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The propeller analysis follows a very similar format.  The areas that are in common will not be repeated, only differences will be highlighted.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Again, we first define the geometry, including the airfoils (which are the same along the blade in this case).  The positive conventions for a propeller (turbine=false) are shown in the figure below.  The underlying theory is unified across the two methods, but the input/output conventions differ to match common usage in the respective domains.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"\n# rotor definition\nRhub = 0.0254*.5\nRtip = 0.0254*3.0\nB = 2  # number of blades\nturbine = false\n\nr = .0254*[0.7526, 0.7928, 0.8329, 0.8731, 0.9132, 0.9586, 1.0332,\n     1.1128, 1.1925, 1.2722, 1.3519, 1.4316, 1.5114, 1.5911,\n     1.6708, 1.7505, 1.8302, 1.9099, 1.9896, 2.0693, 2.1490, 2.2287,\n     2.3084, 2.3881, 2.4678, 2.5475, 2.6273, 2.7070, 2.7867, 2.8661, 2.9410]\nchord = .0254*[0.6270, 0.6255, 0.6231, 0.6199, 0.6165, 0.6125, 0.6054, 0.5973, 0.5887,\n          0.5794, 0.5695, 0.5590, 0.5479, 0.5362, 0.5240, 0.5111, 0.4977,\n          0.4836, 0.4689, 0.4537, 0.4379, 0.4214, 0.4044, 0.3867, 0.3685,\n          0.3497, 0.3303, 0.3103, 0.2897, 0.2618, 0.1920]\ntheta = pi/180.0*[40.2273, 38.7657, 37.3913, 36.0981, 34.8803, 33.5899, 31.6400,\n                   29.7730, 28.0952, 26.5833, 25.2155, 23.9736, 22.8421, 21.8075,\n                   20.8586, 19.9855, 19.1800, 18.4347, 17.7434, 17.1005, 16.5013,\n                   15.9417, 15.4179, 14.9266, 14.4650, 14.0306, 13.6210, 13.2343,\n                   12.8685, 12.5233, 12.2138]\n\naf = af_from_files(\"airfoils/NACA64_A17.dat\")\nairfoils = fill(af, length(r))\n\nrotor = Rotor(Rhub, Rtip, B, turbine)\nsections = Section.(r, chord, theta, airfoils)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"Next, we define the operating point.  For a propeller, it typically doesn't operate with tilt, yaw, and shear like a wind turbine does, so we have defined another convenience function for simple uniform inflow.  Like before, you can always define your own arbitrary inflow object.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"simple_op","category":"page"},{"location":"tutorial/#CCBlade.simple_op","page":"Guide","title":"CCBlade.simple_op","text":"simple_op(Vinf, Omega, r, rho, mu=1.0, asound=1.0, precone=0.0)\n\nUniform inflow through rotor.  Returns an Inflow object.\n\nArguments\n\nVinf::Float: freestream speed (m/s)\nOmega::Float: rotation speed (rad/s)\nr::Float: radial location where inflow is computed (m)\nrho::Float: air density (kg/m^3)\nmu::Float: air viscosity (Pa * s)\nasounnd::Float: air speed of sound (m/s)\nprecone::Float: precone angle (rad)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"In this example, we assume simple inflow, and broadcast across the different radial stations.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"\nrho = 1.225\nVinf = 10.0\nOmega = 8000.0*pi/30.0\n\nop = simple_op.(Vinf, Omega, r, rho)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"We can now computed distributed loads and induced velocities.  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"outputs = solve.(Ref(rotor), sections, op)\n\nfigure()\nplot(r/Rtip, outputs.Np)\nplot(r/Rtip, outputs.Tp)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (N/m)\")\nlegend([\"flapwise\", \"lead-lag\"])\nsavefig(\"loads-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"This time we will also look at the induced velocities.  This is usually not of interest for wind turbines, but for propellers can be useful to assess, for example, prop-on-wing interactions.  These wake velocities have hub/tip corrections applied, whereas intermediate calculations like a do not.  Thus: u does not equal Vx * a.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"figure()\nplot(r/Rtip, outputs.u/Vinf)\nplot(r/Rtip, outputs.v/Vinf)\nxlabel(\"r/Rtip\")\nylabel(\"(normalized) induced velocity at rotor disk\")\nlegend([\"axial velocity\", \"swirl velocity\"])\nsavefig(\"velocity-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: )","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"As before, we'd like to evaluate integrated quantities at multiple conditions in a for loop (advance ratios as is convention for propellers instead of tip-speed ratios).  The normalization conventions for a propeller are:","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"beginaligned\nC_T = fracTrho n^2 D^4\nC_Q = fracQrho n^2 D^5\nC_P = fracPrho n^3 D^5 = fracC_Q2 pi\neta = fracC_T JC_P\nendaligned","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"where","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"beginaligned\nn = fracOmega2pi text rev per sec\nD = 2 R_tip cos(textprecone)\nJ = fracVn D\nendaligned","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"note: Note\nEfficiency is set to zero if the thrust is negative (producing drag).  ","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"The code below performs this analysis then plots thrust coefficient, power coefficient, and efficiency as a function of advance ratio.","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"nJ = 20  # number of advance ratios\n\nJ = range(0.1, 0.9, length=nJ)  # advance ratio\n\nOmega = 8000.0*pi/30\nn = Omega/(2*pi)\nD = 2*Rtip\n\neff = zeros(nJ)\nCT = zeros(nJ)\nCQ = zeros(nJ)\n\nfor i = 1:nJ\n    Vinf = J[i] * D * n\n\n    op = simple_op.(Vinf, Omega, r, rho)\n    outputs = solve.(Ref(rotor), sections, op)\n    T, Q = thrusttorque(rotor, sections, outputs)\n    eff[i], CT[i], CQ[i] = nondim(T, Q, Vinf, Omega, rho, rotor)\n\nend\n\nfigure()\nplot(J, CT)\nplot(J, CQ*2*pi)\nxlabel(L\"J\")\nlegend([L\"C_T\", L\"C_P\"])\nsavefig(\"ctcp-prop.svg\") # hide\n\nfigure()\nplot(J, eff)\nxlabel(L\"J\")\nylabel(L\"\\eta\")\nsavefig(\"eta-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Guide","title":"Guide","text":"(Image: ) (Image: )","category":"page"}]
}
